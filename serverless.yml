service: vehicle-tracking-boilerplate

provider:
  name: aws
  runtime: nodejs12.x
  stage: ${self:custom.Environments.devEnv}
  region: eu-west-1
  iamRoleStatements:
    # TODO Fine tune if you want. This only ensure your lambda has access to every service
    - Effect: "Allow"
      Action:
        - "*"
      Resource: "*"
  environment:
    VEHICLE_STATUS_TABLE: ${self:custom.TransitTable.name}
    TRACKED_VEHICLES: ${self:custom.TrackingTable.name}

functions:
  vehicle-tracker-request:
    handler: index.requestTracker
    description: "Gets location for a vehicle given id"
    events: # events that trigger this action
      - http: # creates an API gateway endpoint
          method: GET
          path: /request/{id}

  vehicle-status-poller:
    handler: index.startPolling
    description: "polls vehicle location"
    events: # events that trigger this action
      - http: # creates an API gateway endpoint
          method: GET
          path: /poll/

  vehicle-status-retrieve:
    handler: index.getVehicleStatus
    description: "Retrieves location of a vehicle"
    events: # events that trigger this action
      - http: # creates an API gateway endpoint
          method: GET
          path: /retreive/{id}

package:
  exclude:
    - "node_modules/aws-sdk/**"

custom:
  webpack:
    webpackConfig: "webpack.config.js" # Name of webpack configuration file
    includeModules: false # Node modules configuration for packaging
    packager: "npm" # Packager that will be used to package your external modules
    excludeFiles: src/**/*.test.js # Provide a glob for files to ignore
  TransitTable:
    name: !Ref "VehicleStatusTable"
    arn: !GetAtt VehicleStatusTable.Arn
  TrackingTable:
    name: !Ref "TrackedVehicles"
    arn: !GetAtt TrackedVehicles.Arn
  Environments:
    devEnv: dev

plugins:
  - serverless-webpack
  - serverless-pseudo-parameters

resources:
  Parameters:
    ServiceName:
      Type: String
      Default: hslpoller
    ImageUrl:
      Type: String
      Default: 034100442440.dkr.ecr.eu-west-1.amazonaws.com/hslpoller:latest
    ContainerPort:
      Type: String
      Default: "80"
    ContainerCpu:
      Type: String
      Default: "256"
    ContainerMemory:
      Type: String
      Default: "0.5GB"
    Path:
      Type: String
      Default: "*"
    DesiredCount:
      Type: String
      Default: "2"

  Resources:
    VPC:
      Type: AWS::EC2::VPC
      Properties:
        EnableDnsSupport: true
        EnableDnsHostnames: true
        CidrBlock: "10.0.0.0/16"

    # Two public subnets where load balancer and NAT gateway will run
    PublicSubnetOne:
      Type: AWS::EC2::Subnet
      Properties:
        AvailabilityZone:
          Fn::Select:
            - 0
            - Fn::GetAZs: { Ref: "AWS::Region" }
        VpcId: !Ref "VPC"
        CidrBlock: "10.0.0.0/24"
        MapPublicIpOnLaunch: true

    PublicSubnetTwo:
      Type: AWS::EC2::Subnet
      Properties:
        AvailabilityZone:
          Fn::Select:
            - 1
            - Fn::GetAZs: { Ref: "AWS::Region" }
        VpcId: !Ref "VPC"
        CidrBlock: "10.0.1.0/24"
        MapPublicIpOnLaunch: true

    # Two private subnets, where containers will run
    PrivateSubnetOne:
      Type: AWS::EC2::Subnet
      Properties:
        AvailabilityZone:
          Fn::Select:
            - 0
            - Fn::GetAZs: { Ref: "AWS::Region" }
        VpcId: !Ref "VPC"
        CidrBlock: "10.0.2.0/24"

    PrivateSubnetTwo:
      Type: AWS::EC2::Subnet
      Properties:
        AvailabilityZone:
          Fn::Select:
            - 1
            - Fn::GetAZs: { Ref: "AWS::Region" }
        VpcId: !Ref "VPC"
        CidrBlock: "10.0.3.0/24"

      # internet gateway
    InternetGateway:
      Type: AWS::EC2::InternetGateway

    GatewayAttachement: # attach vpc to internet gateway, they both have to be created
      Type: AWS::EC2::VPCGatewayAttachment
      Properties:
        VpcId: !Ref "VPC"
        InternetGatewayId: !Ref InternetGateway

    PublicRouteTable: # create route table
      Type: AWS::EC2::RouteTable
      Properties:
        VpcId: !Ref "VPC" # point to vpc

    PublicRoute: # public route table definition
      Type: AWS::EC2::Route
      DependsOn: GatewayAttachement # has to finish creating before this is accessed
      Properties:
        RouteTableId: !Ref "PublicRouteTable"
        DestinationCidrBlock: "0.0.0.0/0"
        GatewayId: !Ref "InternetGateway"
    # subnet associations to route tables
    PublicSubnetOneRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        SubnetId: !Ref PublicSubnetOne
        RouteTableId: !Ref PublicRouteTable
    PublicSubnetTwoRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        SubnetId: !Ref PublicSubnetTwo
        RouteTableId: !Ref PublicRouteTable

    ElasticIPAddress:
      Type: AWS::EC2::EIP
      Properties:
        Domain: VPC

    # A NAT Gateway:
    NATGateway:
      Type: AWS::EC2::NatGateway
      Properties:
        AllocationId: !GetAtt ElasticIPAddress.AllocationId
        SubnetId: !Ref "PublicSubnetOne"
        Tags:
          - Key: Name
            Value: my nat gateway

    PrivateRouteTable: # private route table definition
      Type: AWS::EC2::RouteTable
      Properties:
        VpcId: !Ref "VPC"

    PrivateRoute:
      Type: AWS::EC2::Route
      Properties:
        RouteTableId: !Ref "PrivateRouteTable"
        DestinationCidrBlock: "0.0.0.0/0"
        # route traffic through the NAT gateway
        NatGatewayId: !Ref "NATGateway"
    PrivateSubnetOneRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        SubnetId: !Ref PrivateSubnetOne
        RouteTableId: !Ref PrivateRouteTable
    PrivateSubnetTwoRouteTableAssociation:
      Type: AWS::EC2::SubnetRouteTableAssociation
      Properties:
        SubnetId: !Ref PrivateSubnetTwo
        RouteTableId: !Ref PrivateRouteTable

    VehicleStatusTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: Transit-Table-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH

    TrackedVehicles:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: TrackedVehicles-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S
        KeySchema:
          - AttributeName: id
            KeyType: HASH

    # ECS Resources
    ECSCluster:
      Type: AWS::ECS::Cluster

    # Task definition that ECS is going to run
    FargateTaskDefinition:
      Type: AWS::ECS::TaskDefinition
      # Makes sure the log group is created before it is used.
      DependsOn: LogGroup
      Properties:
        Family: !Ref "ServiceName"
        Cpu: "256"
        Memory: 0.5GB
        NetworkMode: awsvpc
        RequiresCompatibilities:
          - FARGATE
        ExecutionRoleArn: !Ref ExecutionRole
        TaskRoleArn: !Ref TaskRole
        ContainerDefinitions:
          - Name: !Ref "ServiceName"
            Image: "#{AWS::AccountId}.dkr.ecr.#{AWS::Region}.amazonaws.com/#{ImageUrl}"
            PortMappings:
              - ContainerPort: 8080
            LogConfiguration:
              LogDriver: awslogs
              Options:
                awslogs-region: !Ref AWS::Region
                awslogs-group: !Ref LogGroup
                awslogs-stream-prefix: ecs
            Secrets:
              - Name: "environment"
                ValueFrom: "arn:aws:secretsmanager:eu-west-1:034100442440:secret:hslpollersecrets-edUXWC"

    ExecutionRole:
      Type: AWS::IAM::Role
      Properties:
        RoleName: !Join ["", [!Ref ServiceName, ExecutionRole]]
        AssumeRolePolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: ecs-tasks.amazonaws.com
              Action: "sts:AssumeRole"
        ManagedPolicyArns:
          - "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
    # A role for the containers
    TaskRole:
      Type: AWS::IAM::Role
      Properties:
        RoleName: !Join ["", [!Ref ServiceName, TaskRole]]
        AssumeRolePolicyDocument:
          Statement:
            - Effect: Allow
              Principal:
                Service: ecs-tasks.amazonaws.com
              Action: "sts:AssumeRole"

    LogGroup:
      Type: AWS::Logs::LogGroup
      Properties:
        LogGroupName: !Join ["", [/ecs/, !Ref ServiceName, TaskDefinition]]

      # The service. The service is a resource which allows you to run multiple
    # copies of a type of task, and gather up their logs and metrics, as well
    # as monitor the number of running tasks and replace any that have crashed

    ListenerHTTP: #specifies a listener for our load balancer
      Type: AWS::ElasticLoadBalancingV2::Listener
      Properties:
        DefaultActions:
          - TargetGroupArn: !Ref TargetGroup
            Type: forward
        LoadBalancerArn: !Ref LoadBalancer
        Port: 80
        Protocol: HTTP

    LoadBalancer:
      Type: AWS::ElasticLoadBalancingV2::LoadBalancer
      Properties:
        LoadBalancerAttributes:
          # this is the default, but is specified here in case it needs to be changed
          - Key: idle_timeout.timeout_seconds
            Value: "60"
        Name: !Join ["", [!Ref ServiceName, LoadBalancer]]
        # "internal" is also an option
        Scheme: internet-facing
        SecurityGroups:
          - !Ref LoadBalancerSecurityGroup
        Subnets: # where the load balancer runs
          - !Ref PublicSubnetOne
          - !Ref PublicSubnetTwo

    LoadBalancerSecurityGroup:
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupDescription:
          !Join ["", [!Ref ServiceName, LoadBalancerSecurityGroup]]
        VpcId: !Ref VPC
        SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 80
            ToPort: 80
            CidrIp: 0.0.0.0/0 # will be forwarded to the target group

    TargetGroup:
      Type: AWS::ElasticLoadBalancingV2::TargetGroup
      Properties:
        HealthCheckIntervalSeconds: 30
        # will look for a 200 status code by default unless specified otherwise
        HealthCheckPath: "/health"
        HealthCheckTimeoutSeconds: 5
        UnhealthyThresholdCount: 2
        HealthyThresholdCount: 2
        Name: !Join ["", [!Ref ServiceName, TargetGroup]]
        Port: !Ref 80
        Protocol: HTTP
        TargetGroupAttributes:
          - Key: deregistration_delay.timeout_seconds
            Value: "300" # deregistry delay
        TargetType: ip
        VpcId: !Ref VPC
    ContainerSecurityGroup:
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupDescription: !Join ["", [!Ref ServiceName, ContainerSecurityGroup]]
        VpcId: !Ref VPC
        SecurityGroupIngress:
          - IpProtocol: tcp
            FromPort: 80
            ToPort: 80
            SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
    Service:
      Type: AWS::ECS::Service
      # This dependency is needed so that the load balancer is setup correctly in time
      DependsOn:
        - ListenerHTTP
      Properties:
        ServiceName: !Ref ServiceName
        Cluster: !Ref ECSCluster
        TaskDefinition: !Ref FargateTaskDefinition
        DeploymentConfiguration:
          MinimumHealthyPercent: 100
          MaximumPercent: 200
        DesiredCount: 2
        # This may need to be adjusted if the container takes a while to start up
        HealthCheckGracePeriodSeconds: 30
        LaunchType: FARGATE
        NetworkConfiguration:
          AwsvpcConfiguration:
            # change to DISABLED if you're using private subnets that have access to a NAT gateway
            AssignPublicIp: DISABLED
            Subnets: # reference to location running containers
              - !Ref PrivateSubnetOne
              - !Ref PrivateSubnetTwo
            SecurityGroups:
              - !Ref ContainerSecurityGroup
        LoadBalancers:
          - ContainerName: !Ref ServiceName
            ContainerPort: 80
            TargetGroupArn: !Ref TargetGroup
